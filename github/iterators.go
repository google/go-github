// Code generated by gen-iterators; DO NOT EDIT.

// Copyright 2026 The go-github AUTHORS. All rights reserved.
//
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package github

import (
	"context"
	"iter"
)

// ListEventsIter returns an iterator that paginates through all results of ListEvents.
func (s *ActivityService) ListEventsIter(ctx context.Context, opts *ListOptions) iter.Seq2[*Event, error] {
	return func(yield func(*Event, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListEvents(ctx, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListEventsForOrganizationIter returns an iterator that paginates through all results of ListEventsForOrganization.
func (s *ActivityService) ListEventsForOrganizationIter(ctx context.Context, org string, opts *ListOptions) iter.Seq2[*Event, error] {
	return func(yield func(*Event, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListEventsForOrganization(ctx, org, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListEventsForRepoNetworkIter returns an iterator that paginates through all results of ListEventsForRepoNetwork.
func (s *ActivityService) ListEventsForRepoNetworkIter(ctx context.Context, owner string, repo string, opts *ListOptions) iter.Seq2[*Event, error] {
	return func(yield func(*Event, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListEventsForRepoNetwork(ctx, owner, repo, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListEventsPerformedByUserIter returns an iterator that paginates through all results of ListEventsPerformedByUser.
func (s *ActivityService) ListEventsPerformedByUserIter(ctx context.Context, user string, publicOnly bool, opts *ListOptions) iter.Seq2[*Event, error] {
	return func(yield func(*Event, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListEventsPerformedByUser(ctx, user, publicOnly, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListEventsReceivedByUserIter returns an iterator that paginates through all results of ListEventsReceivedByUser.
func (s *ActivityService) ListEventsReceivedByUserIter(ctx context.Context, user string, publicOnly bool, opts *ListOptions) iter.Seq2[*Event, error] {
	return func(yield func(*Event, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListEventsReceivedByUser(ctx, user, publicOnly, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListIssueEventsForRepositoryIter returns an iterator that paginates through all results of ListIssueEventsForRepository.
func (s *ActivityService) ListIssueEventsForRepositoryIter(ctx context.Context, owner string, repo string, opts *ListOptions) iter.Seq2[*IssueEvent, error] {
	return func(yield func(*IssueEvent, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListIssueEventsForRepository(ctx, owner, repo, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListNotificationsIter returns an iterator that paginates through all results of ListNotifications.
func (s *ActivityService) ListNotificationsIter(ctx context.Context, opts *NotificationListOptions) iter.Seq2[*Notification, error] {
	return func(yield func(*Notification, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &NotificationListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListNotifications(ctx, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.ListOptions.Page = resp.NextPage

		}
	}
}

// ListRepositoryEventsIter returns an iterator that paginates through all results of ListRepositoryEvents.
func (s *ActivityService) ListRepositoryEventsIter(ctx context.Context, owner string, repo string, opts *ListOptions) iter.Seq2[*Event, error] {
	return func(yield func(*Event, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListRepositoryEvents(ctx, owner, repo, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListRepositoryNotificationsIter returns an iterator that paginates through all results of ListRepositoryNotifications.
func (s *ActivityService) ListRepositoryNotificationsIter(ctx context.Context, owner string, repo string, opts *NotificationListOptions) iter.Seq2[*Notification, error] {
	return func(yield func(*Notification, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &NotificationListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListRepositoryNotifications(ctx, owner, repo, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.ListOptions.Page = resp.NextPage

		}
	}
}

// ListStargazersIter returns an iterator that paginates through all results of ListStargazers.
func (s *ActivityService) ListStargazersIter(ctx context.Context, owner string, repo string, opts *ListOptions) iter.Seq2[*Stargazer, error] {
	return func(yield func(*Stargazer, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListStargazers(ctx, owner, repo, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListStarredIter returns an iterator that paginates through all results of ListStarred.
func (s *ActivityService) ListStarredIter(ctx context.Context, user string, opts *ActivityListStarredOptions) iter.Seq2[*StarredRepository, error] {
	return func(yield func(*StarredRepository, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ActivityListStarredOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListStarred(ctx, user, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.ListOptions.Page = resp.NextPage

		}
	}
}

// ListUserEventsForOrganizationIter returns an iterator that paginates through all results of ListUserEventsForOrganization.
func (s *ActivityService) ListUserEventsForOrganizationIter(ctx context.Context, org string, user string, opts *ListOptions) iter.Seq2[*Event, error] {
	return func(yield func(*Event, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListUserEventsForOrganization(ctx, org, user, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListWatchedIter returns an iterator that paginates through all results of ListWatched.
func (s *ActivityService) ListWatchedIter(ctx context.Context, user string, opts *ListOptions) iter.Seq2[*Repository, error] {
	return func(yield func(*Repository, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListWatched(ctx, user, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListWatchersIter returns an iterator that paginates through all results of ListWatchers.
func (s *ActivityService) ListWatchersIter(ctx context.Context, owner string, repo string, opts *ListOptions) iter.Seq2[*User, error] {
	return func(yield func(*User, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListWatchers(ctx, owner, repo, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListInstallationRequestsIter returns an iterator that paginates through all results of ListInstallationRequests.
func (s *AppsService) ListInstallationRequestsIter(ctx context.Context, opts *ListOptions) iter.Seq2[*InstallationRequest, error] {
	return func(yield func(*InstallationRequest, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListInstallationRequests(ctx, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListInstallationsIter returns an iterator that paginates through all results of ListInstallations.
func (s *AppsService) ListInstallationsIter(ctx context.Context, opts *ListOptions) iter.Seq2[*Installation, error] {
	return func(yield func(*Installation, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListInstallations(ctx, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListUserInstallationsIter returns an iterator that paginates through all results of ListUserInstallations.
func (s *AppsService) ListUserInstallationsIter(ctx context.Context, opts *ListOptions) iter.Seq2[*Installation, error] {
	return func(yield func(*Installation, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListUserInstallations(ctx, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListCheckRunAnnotationsIter returns an iterator that paginates through all results of ListCheckRunAnnotations.
func (s *ChecksService) ListCheckRunAnnotationsIter(ctx context.Context, owner string, repo string, checkRunID int64, opts *ListOptions) iter.Seq2[*CheckRunAnnotation, error] {
	return func(yield func(*CheckRunAnnotation, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListCheckRunAnnotations(ctx, owner, repo, checkRunID, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListAcceptedAssignmentsIter returns an iterator that paginates through all results of ListAcceptedAssignments.
func (s *ClassroomService) ListAcceptedAssignmentsIter(ctx context.Context, assignmentID int64, opts *ListOptions) iter.Seq2[*AcceptedAssignment, error] {
	return func(yield func(*AcceptedAssignment, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListAcceptedAssignments(ctx, assignmentID, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListClassroomAssignmentsIter returns an iterator that paginates through all results of ListClassroomAssignments.
func (s *ClassroomService) ListClassroomAssignmentsIter(ctx context.Context, classroomID int64, opts *ListOptions) iter.Seq2[*ClassroomAssignment, error] {
	return func(yield func(*ClassroomAssignment, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListClassroomAssignments(ctx, classroomID, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListClassroomsIter returns an iterator that paginates through all results of ListClassrooms.
func (s *ClassroomService) ListClassroomsIter(ctx context.Context, opts *ListOptions) iter.Seq2[*Classroom, error] {
	return func(yield func(*Classroom, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListClassrooms(ctx, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListAlertInstancesIter returns an iterator that paginates through all results of ListAlertInstances.
func (s *CodeScanningService) ListAlertInstancesIter(ctx context.Context, owner string, repo string, id int64, opts *AlertInstancesListOptions) iter.Seq2[*MostRecentInstance, error] {
	return func(yield func(*MostRecentInstance, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &AlertInstancesListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListAlertInstances(ctx, owner, repo, id, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.ListOptions.Page = resp.NextPage

		}
	}
}

// ListAlertsForOrgIter returns an iterator that paginates through all results of ListAlertsForOrg.
func (s *CodeScanningService) ListAlertsForOrgIter(ctx context.Context, org string, opts *AlertListOptions) iter.Seq2[*Alert, error] {
	return func(yield func(*Alert, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &AlertListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListAlertsForOrg(ctx, org, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.ListOptions.Page = resp.NextPage

		}
	}
}

// ListAlertsForRepoIter returns an iterator that paginates through all results of ListAlertsForRepo.
func (s *CodeScanningService) ListAlertsForRepoIter(ctx context.Context, owner string, repo string, opts *AlertListOptions) iter.Seq2[*Alert, error] {
	return func(yield func(*Alert, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &AlertListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListAlertsForRepo(ctx, owner, repo, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.ListOptions.Page = resp.NextPage

		}
	}
}

// ListAnalysesForRepoIter returns an iterator that paginates through all results of ListAnalysesForRepo.
func (s *CodeScanningService) ListAnalysesForRepoIter(ctx context.Context, owner string, repo string, opts *AnalysesListOptions) iter.Seq2[*ScanningAnalysis, error] {
	return func(yield func(*ScanningAnalysis, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &AnalysesListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListAnalysesForRepo(ctx, owner, repo, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.ListOptions.Page = resp.NextPage

		}
	}
}

// ListOrgAlertsIter returns an iterator that paginates through all results of ListOrgAlerts.
func (s *DependabotService) ListOrgAlertsIter(ctx context.Context, org string, opts *ListAlertsOptions) iter.Seq2[*DependabotAlert, error] {
	return func(yield func(*DependabotAlert, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListAlertsOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListOrgAlerts(ctx, org, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.ListOptions.Page = resp.NextPage

		}
	}
}

// ListRepoAlertsIter returns an iterator that paginates through all results of ListRepoAlerts.
func (s *DependabotService) ListRepoAlertsIter(ctx context.Context, owner string, repo string, opts *ListAlertsOptions) iter.Seq2[*DependabotAlert, error] {
	return func(yield func(*DependabotAlert, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListAlertsOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListRepoAlerts(ctx, owner, repo, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.ListOptions.Page = resp.NextPage

		}
	}
}

// ListAppAccessibleOrganizationRepositoriesIter returns an iterator that paginates through all results of ListAppAccessibleOrganizationRepositories.
func (s *EnterpriseService) ListAppAccessibleOrganizationRepositoriesIter(ctx context.Context, enterprise string, org string, opts *ListOptions) iter.Seq2[*AccessibleRepository, error] {
	return func(yield func(*AccessibleRepository, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListAppAccessibleOrganizationRepositories(ctx, enterprise, org, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListAppInstallableOrganizationsIter returns an iterator that paginates through all results of ListAppInstallableOrganizations.
func (s *EnterpriseService) ListAppInstallableOrganizationsIter(ctx context.Context, enterprise string, opts *ListOptions) iter.Seq2[*InstallableOrganization, error] {
	return func(yield func(*InstallableOrganization, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListAppInstallableOrganizations(ctx, enterprise, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListAppInstallationsIter returns an iterator that paginates through all results of ListAppInstallations.
func (s *EnterpriseService) ListAppInstallationsIter(ctx context.Context, enterprise string, org string, opts *ListOptions) iter.Seq2[*Installation, error] {
	return func(yield func(*Installation, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListAppInstallations(ctx, enterprise, org, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListAssignmentsIter returns an iterator that paginates through all results of ListAssignments.
func (s *EnterpriseService) ListAssignmentsIter(ctx context.Context, enterprise string, enterpriseTeam string, opts *ListOptions) iter.Seq2[*Organization, error] {
	return func(yield func(*Organization, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListAssignments(ctx, enterprise, enterpriseTeam, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListOrganizationCustomPropertyValuesIter returns an iterator that paginates through all results of ListOrganizationCustomPropertyValues.
func (s *EnterpriseService) ListOrganizationCustomPropertyValuesIter(ctx context.Context, enterprise string, opts *ListOptions) iter.Seq2[*EnterpriseCustomPropertiesValues, error] {
	return func(yield func(*EnterpriseCustomPropertiesValues, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListOrganizationCustomPropertyValues(ctx, enterprise, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListRepositoriesForOrgAppInstallationIter returns an iterator that paginates through all results of ListRepositoriesForOrgAppInstallation.
func (s *EnterpriseService) ListRepositoriesForOrgAppInstallationIter(ctx context.Context, enterprise string, org string, installationID int64, opts *ListOptions) iter.Seq2[*AccessibleRepository, error] {
	return func(yield func(*AccessibleRepository, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListRepositoriesForOrgAppInstallation(ctx, enterprise, org, installationID, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListTeamMembersIter returns an iterator that paginates through all results of ListTeamMembers.
func (s *EnterpriseService) ListTeamMembersIter(ctx context.Context, enterprise string, enterpriseTeam string, opts *ListOptions) iter.Seq2[*User, error] {
	return func(yield func(*User, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListTeamMembers(ctx, enterprise, enterpriseTeam, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListTeamsIter returns an iterator that paginates through all results of ListTeams.
func (s *EnterpriseService) ListTeamsIter(ctx context.Context, enterprise string, opts *ListOptions) iter.Seq2[*EnterpriseTeam, error] {
	return func(yield func(*EnterpriseTeam, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListTeams(ctx, enterprise, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListIter returns an iterator that paginates through all results of List.
func (s *GistsService) ListIter(ctx context.Context, user string, opts *GistListOptions) iter.Seq2[*Gist, error] {
	return func(yield func(*Gist, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &GistListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.List(ctx, user, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.ListOptions.Page = resp.NextPage

		}
	}
}

// ListAllIter returns an iterator that paginates through all results of ListAll.
func (s *GistsService) ListAllIter(ctx context.Context, opts *GistListOptions) iter.Seq2[*Gist, error] {
	return func(yield func(*Gist, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &GistListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListAll(ctx, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.ListOptions.Page = resp.NextPage

		}
	}
}

// ListCommentsIter returns an iterator that paginates through all results of ListComments.
func (s *GistsService) ListCommentsIter(ctx context.Context, gistID string, opts *ListOptions) iter.Seq2[*GistComment, error] {
	return func(yield func(*GistComment, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListComments(ctx, gistID, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListCommitsIter returns an iterator that paginates through all results of ListCommits.
func (s *GistsService) ListCommitsIter(ctx context.Context, id string, opts *ListOptions) iter.Seq2[*GistCommit, error] {
	return func(yield func(*GistCommit, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListCommits(ctx, id, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListForksIter returns an iterator that paginates through all results of ListForks.
func (s *GistsService) ListForksIter(ctx context.Context, id string, opts *ListOptions) iter.Seq2[*GistFork, error] {
	return func(yield func(*GistFork, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListForks(ctx, id, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListStarredIter returns an iterator that paginates through all results of ListStarred.
func (s *GistsService) ListStarredIter(ctx context.Context, opts *GistListOptions) iter.Seq2[*Gist, error] {
	return func(yield func(*Gist, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &GistListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListStarred(ctx, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.ListOptions.Page = resp.NextPage

		}
	}
}

// ListIter returns an iterator that paginates through all results of List.
func (s *IssuesService) ListIter(ctx context.Context, all bool, opts *IssueListOptions) iter.Seq2[*Issue, error] {
	return func(yield func(*Issue, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &IssueListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.List(ctx, all, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.ListOptions.Page = resp.NextPage

		}
	}
}

// ListAssigneesIter returns an iterator that paginates through all results of ListAssignees.
func (s *IssuesService) ListAssigneesIter(ctx context.Context, owner string, repo string, opts *ListOptions) iter.Seq2[*User, error] {
	return func(yield func(*User, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListAssignees(ctx, owner, repo, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListByOrgIter returns an iterator that paginates through all results of ListByOrg.
func (s *IssuesService) ListByOrgIter(ctx context.Context, org string, opts *IssueListOptions) iter.Seq2[*Issue, error] {
	return func(yield func(*Issue, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &IssueListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListByOrg(ctx, org, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.ListOptions.Page = resp.NextPage

		}
	}
}

// ListByRepoIter returns an iterator that paginates through all results of ListByRepo.
func (s *IssuesService) ListByRepoIter(ctx context.Context, owner string, repo string, opts *IssueListByRepoOptions) iter.Seq2[*Issue, error] {
	return func(yield func(*Issue, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &IssueListByRepoOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListByRepo(ctx, owner, repo, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.ListOptions.Page = resp.NextPage

		}
	}
}

// ListCommentsIter returns an iterator that paginates through all results of ListComments.
func (s *IssuesService) ListCommentsIter(ctx context.Context, owner string, repo string, number int, opts *IssueListCommentsOptions) iter.Seq2[*IssueComment, error] {
	return func(yield func(*IssueComment, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &IssueListCommentsOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListComments(ctx, owner, repo, number, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.ListOptions.Page = resp.NextPage

		}
	}
}

// ListIssueEventsIter returns an iterator that paginates through all results of ListIssueEvents.
func (s *IssuesService) ListIssueEventsIter(ctx context.Context, owner string, repo string, number int, opts *ListOptions) iter.Seq2[*IssueEvent, error] {
	return func(yield func(*IssueEvent, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListIssueEvents(ctx, owner, repo, number, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListIssueTimelineIter returns an iterator that paginates through all results of ListIssueTimeline.
func (s *IssuesService) ListIssueTimelineIter(ctx context.Context, owner string, repo string, number int, opts *ListOptions) iter.Seq2[*Timeline, error] {
	return func(yield func(*Timeline, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListIssueTimeline(ctx, owner, repo, number, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListLabelsIter returns an iterator that paginates through all results of ListLabels.
func (s *IssuesService) ListLabelsIter(ctx context.Context, owner string, repo string, opts *ListOptions) iter.Seq2[*Label, error] {
	return func(yield func(*Label, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListLabels(ctx, owner, repo, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListLabelsByIssueIter returns an iterator that paginates through all results of ListLabelsByIssue.
func (s *IssuesService) ListLabelsByIssueIter(ctx context.Context, owner string, repo string, number int, opts *ListOptions) iter.Seq2[*Label, error] {
	return func(yield func(*Label, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListLabelsByIssue(ctx, owner, repo, number, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListLabelsForMilestoneIter returns an iterator that paginates through all results of ListLabelsForMilestone.
func (s *IssuesService) ListLabelsForMilestoneIter(ctx context.Context, owner string, repo string, number int, opts *ListOptions) iter.Seq2[*Label, error] {
	return func(yield func(*Label, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListLabelsForMilestone(ctx, owner, repo, number, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListMilestonesIter returns an iterator that paginates through all results of ListMilestones.
func (s *IssuesService) ListMilestonesIter(ctx context.Context, owner string, repo string, opts *MilestoneListOptions) iter.Seq2[*Milestone, error] {
	return func(yield func(*Milestone, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &MilestoneListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListMilestones(ctx, owner, repo, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.ListOptions.Page = resp.NextPage

		}
	}
}

// ListRepositoryEventsIter returns an iterator that paginates through all results of ListRepositoryEvents.
func (s *IssuesService) ListRepositoryEventsIter(ctx context.Context, owner string, repo string, opts *ListOptions) iter.Seq2[*IssueEvent, error] {
	return func(yield func(*IssueEvent, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListRepositoryEvents(ctx, owner, repo, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListMarketplacePurchasesForUserIter returns an iterator that paginates through all results of ListMarketplacePurchasesForUser.
func (s *MarketplaceService) ListMarketplacePurchasesForUserIter(ctx context.Context, opts *ListOptions) iter.Seq2[*MarketplacePurchase, error] {
	return func(yield func(*MarketplacePurchase, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListMarketplacePurchasesForUser(ctx, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListPlanAccountsForPlanIter returns an iterator that paginates through all results of ListPlanAccountsForPlan.
func (s *MarketplaceService) ListPlanAccountsForPlanIter(ctx context.Context, planID int64, opts *ListOptions) iter.Seq2[*MarketplacePlanAccount, error] {
	return func(yield func(*MarketplacePlanAccount, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListPlanAccountsForPlan(ctx, planID, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListPlansIter returns an iterator that paginates through all results of ListPlans.
func (s *MarketplaceService) ListPlansIter(ctx context.Context, opts *ListOptions) iter.Seq2[*MarketplacePlan, error] {
	return func(yield func(*MarketplacePlan, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListPlans(ctx, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListMigrationsIter returns an iterator that paginates through all results of ListMigrations.
func (s *MigrationService) ListMigrationsIter(ctx context.Context, org string, opts *ListOptions) iter.Seq2[*Migration, error] {
	return func(yield func(*Migration, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListMigrations(ctx, org, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListUserMigrationsIter returns an iterator that paginates through all results of ListUserMigrations.
func (s *MigrationService) ListUserMigrationsIter(ctx context.Context, opts *ListOptions) iter.Seq2[*UserMigration, error] {
	return func(yield func(*UserMigration, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListUserMigrations(ctx, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListIter returns an iterator that paginates through all results of List.
func (s *OrganizationsService) ListIter(ctx context.Context, user string, opts *ListOptions) iter.Seq2[*Organization, error] {
	return func(yield func(*Organization, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.List(ctx, user, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListAllIter returns an iterator that paginates through all results of ListAll.
func (s *OrganizationsService) ListAllIter(ctx context.Context, opts *OrganizationsListOptions) iter.Seq2[*Organization, error] {
	return func(yield func(*Organization, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &OrganizationsListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListAll(ctx, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.ListOptions.Page = resp.NextPage

		}
	}
}

// ListBlockedUsersIter returns an iterator that paginates through all results of ListBlockedUsers.
func (s *OrganizationsService) ListBlockedUsersIter(ctx context.Context, org string, opts *ListOptions) iter.Seq2[*User, error] {
	return func(yield func(*User, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListBlockedUsers(ctx, org, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListCredentialAuthorizationsIter returns an iterator that paginates through all results of ListCredentialAuthorizations.
func (s *OrganizationsService) ListCredentialAuthorizationsIter(ctx context.Context, org string, opts *CredentialAuthorizationsListOptions) iter.Seq2[*CredentialAuthorization, error] {
	return func(yield func(*CredentialAuthorization, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &CredentialAuthorizationsListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListCredentialAuthorizations(ctx, org, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.ListOptions.Page = resp.NextPage

		}
	}
}

// ListCustomPropertyValuesIter returns an iterator that paginates through all results of ListCustomPropertyValues.
func (s *OrganizationsService) ListCustomPropertyValuesIter(ctx context.Context, org string, opts *ListCustomPropertyValuesOptions) iter.Seq2[*RepoCustomPropertyValue, error] {
	return func(yield func(*RepoCustomPropertyValue, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListCustomPropertyValuesOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListCustomPropertyValues(ctx, org, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.ListOptions.Page = resp.NextPage

		}
	}
}

// ListFailedOrgInvitationsIter returns an iterator that paginates through all results of ListFailedOrgInvitations.
func (s *OrganizationsService) ListFailedOrgInvitationsIter(ctx context.Context, org string, opts *ListOptions) iter.Seq2[*Invitation, error] {
	return func(yield func(*Invitation, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListFailedOrgInvitations(ctx, org, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListFineGrainedPersonalAccessTokensIter returns an iterator that paginates through all results of ListFineGrainedPersonalAccessTokens.
func (s *OrganizationsService) ListFineGrainedPersonalAccessTokensIter(ctx context.Context, org string, opts *ListFineGrainedPATOptions) iter.Seq2[*PersonalAccessToken, error] {
	return func(yield func(*PersonalAccessToken, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListFineGrainedPATOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListFineGrainedPersonalAccessTokens(ctx, org, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.ListOptions.Page = resp.NextPage

		}
	}
}

// ListHooksIter returns an iterator that paginates through all results of ListHooks.
func (s *OrganizationsService) ListHooksIter(ctx context.Context, org string, opts *ListOptions) iter.Seq2[*Hook, error] {
	return func(yield func(*Hook, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListHooks(ctx, org, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListMembersIter returns an iterator that paginates through all results of ListMembers.
func (s *OrganizationsService) ListMembersIter(ctx context.Context, org string, opts *ListMembersOptions) iter.Seq2[*User, error] {
	return func(yield func(*User, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListMembersOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListMembers(ctx, org, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.ListOptions.Page = resp.NextPage

		}
	}
}

// ListOrgInvitationTeamsIter returns an iterator that paginates through all results of ListOrgInvitationTeams.
func (s *OrganizationsService) ListOrgInvitationTeamsIter(ctx context.Context, org string, invitationID string, opts *ListOptions) iter.Seq2[*Team, error] {
	return func(yield func(*Team, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListOrgInvitationTeams(ctx, org, invitationID, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListOrgMembershipsIter returns an iterator that paginates through all results of ListOrgMemberships.
func (s *OrganizationsService) ListOrgMembershipsIter(ctx context.Context, opts *ListOrgMembershipsOptions) iter.Seq2[*Membership, error] {
	return func(yield func(*Membership, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOrgMembershipsOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListOrgMemberships(ctx, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.ListOptions.Page = resp.NextPage

		}
	}
}

// ListOutsideCollaboratorsIter returns an iterator that paginates through all results of ListOutsideCollaborators.
func (s *OrganizationsService) ListOutsideCollaboratorsIter(ctx context.Context, org string, opts *ListOutsideCollaboratorsOptions) iter.Seq2[*User, error] {
	return func(yield func(*User, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOutsideCollaboratorsOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListOutsideCollaborators(ctx, org, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.ListOptions.Page = resp.NextPage

		}
	}
}

// ListPackagesIter returns an iterator that paginates through all results of ListPackages.
func (s *OrganizationsService) ListPackagesIter(ctx context.Context, org string, opts *PackageListOptions) iter.Seq2[*Package, error] {
	return func(yield func(*Package, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &PackageListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListPackages(ctx, org, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.ListOptions.Page = resp.NextPage

		}
	}
}

// ListPendingOrgInvitationsIter returns an iterator that paginates through all results of ListPendingOrgInvitations.
func (s *OrganizationsService) ListPendingOrgInvitationsIter(ctx context.Context, org string, opts *ListOptions) iter.Seq2[*Invitation, error] {
	return func(yield func(*Invitation, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListPendingOrgInvitations(ctx, org, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListTeamsAssignedToOrgRoleIter returns an iterator that paginates through all results of ListTeamsAssignedToOrgRole.
func (s *OrganizationsService) ListTeamsAssignedToOrgRoleIter(ctx context.Context, org string, roleID int64, opts *ListOptions) iter.Seq2[*Team, error] {
	return func(yield func(*Team, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListTeamsAssignedToOrgRole(ctx, org, roleID, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListUsersAssignedToOrgRoleIter returns an iterator that paginates through all results of ListUsersAssignedToOrgRole.
func (s *OrganizationsService) ListUsersAssignedToOrgRoleIter(ctx context.Context, org string, roleID int64, opts *ListOptions) iter.Seq2[*User, error] {
	return func(yield func(*User, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListUsersAssignedToOrgRole(ctx, org, roleID, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListIter returns an iterator that paginates through all results of List.
func (s *PullRequestsService) ListIter(ctx context.Context, owner string, repo string, opts *PullRequestListOptions) iter.Seq2[*PullRequest, error] {
	return func(yield func(*PullRequest, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &PullRequestListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.List(ctx, owner, repo, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.ListOptions.Page = resp.NextPage

		}
	}
}

// ListCommentsIter returns an iterator that paginates through all results of ListComments.
func (s *PullRequestsService) ListCommentsIter(ctx context.Context, owner string, repo string, number int, opts *PullRequestListCommentsOptions) iter.Seq2[*PullRequestComment, error] {
	return func(yield func(*PullRequestComment, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &PullRequestListCommentsOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListComments(ctx, owner, repo, number, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.ListOptions.Page = resp.NextPage

		}
	}
}

// ListCommitsIter returns an iterator that paginates through all results of ListCommits.
func (s *PullRequestsService) ListCommitsIter(ctx context.Context, owner string, repo string, number int, opts *ListOptions) iter.Seq2[*RepositoryCommit, error] {
	return func(yield func(*RepositoryCommit, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListCommits(ctx, owner, repo, number, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListFilesIter returns an iterator that paginates through all results of ListFiles.
func (s *PullRequestsService) ListFilesIter(ctx context.Context, owner string, repo string, number int, opts *ListOptions) iter.Seq2[*CommitFile, error] {
	return func(yield func(*CommitFile, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListFiles(ctx, owner, repo, number, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListPullRequestsWithCommitIter returns an iterator that paginates through all results of ListPullRequestsWithCommit.
func (s *PullRequestsService) ListPullRequestsWithCommitIter(ctx context.Context, owner string, repo string, sha string, opts *ListOptions) iter.Seq2[*PullRequest, error] {
	return func(yield func(*PullRequest, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListPullRequestsWithCommit(ctx, owner, repo, sha, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListReviewCommentsIter returns an iterator that paginates through all results of ListReviewComments.
func (s *PullRequestsService) ListReviewCommentsIter(ctx context.Context, owner string, repo string, number int, reviewID int64, opts *ListOptions) iter.Seq2[*PullRequestComment, error] {
	return func(yield func(*PullRequestComment, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListReviewComments(ctx, owner, repo, number, reviewID, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListReviewsIter returns an iterator that paginates through all results of ListReviews.
func (s *PullRequestsService) ListReviewsIter(ctx context.Context, owner string, repo string, number int, opts *ListOptions) iter.Seq2[*PullRequestReview, error] {
	return func(yield func(*PullRequestReview, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListReviews(ctx, owner, repo, number, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListCommentReactionsIter returns an iterator that paginates through all results of ListCommentReactions.
func (s *ReactionsService) ListCommentReactionsIter(ctx context.Context, owner string, repo string, id int64, opts *ListReactionOptions) iter.Seq2[*Reaction, error] {
	return func(yield func(*Reaction, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListReactionOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListCommentReactions(ctx, owner, repo, id, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.ListOptions.Page = resp.NextPage

		}
	}
}

// ListIssueCommentReactionsIter returns an iterator that paginates through all results of ListIssueCommentReactions.
func (s *ReactionsService) ListIssueCommentReactionsIter(ctx context.Context, owner string, repo string, id int64, opts *ListReactionOptions) iter.Seq2[*Reaction, error] {
	return func(yield func(*Reaction, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListReactionOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListIssueCommentReactions(ctx, owner, repo, id, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.ListOptions.Page = resp.NextPage

		}
	}
}

// ListIssueReactionsIter returns an iterator that paginates through all results of ListIssueReactions.
func (s *ReactionsService) ListIssueReactionsIter(ctx context.Context, owner string, repo string, number int, opts *ListReactionOptions) iter.Seq2[*Reaction, error] {
	return func(yield func(*Reaction, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListReactionOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListIssueReactions(ctx, owner, repo, number, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.ListOptions.Page = resp.NextPage

		}
	}
}

// ListPullRequestCommentReactionsIter returns an iterator that paginates through all results of ListPullRequestCommentReactions.
func (s *ReactionsService) ListPullRequestCommentReactionsIter(ctx context.Context, owner string, repo string, id int64, opts *ListReactionOptions) iter.Seq2[*Reaction, error] {
	return func(yield func(*Reaction, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListReactionOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListPullRequestCommentReactions(ctx, owner, repo, id, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.ListOptions.Page = resp.NextPage

		}
	}
}

// ListReleaseReactionsIter returns an iterator that paginates through all results of ListReleaseReactions.
func (s *ReactionsService) ListReleaseReactionsIter(ctx context.Context, owner string, repo string, releaseID int64, opts *ListReactionOptions) iter.Seq2[*Reaction, error] {
	return func(yield func(*Reaction, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListReactionOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListReleaseReactions(ctx, owner, repo, releaseID, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.ListOptions.Page = resp.NextPage

		}
	}
}

// ListTeamDiscussionCommentReactionsIter returns an iterator that paginates through all results of ListTeamDiscussionCommentReactions.
func (s *ReactionsService) ListTeamDiscussionCommentReactionsIter(ctx context.Context, teamID int64, discussionNumber int, commentNumber int, opts *ListReactionOptions) iter.Seq2[*Reaction, error] {
	return func(yield func(*Reaction, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListReactionOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListTeamDiscussionCommentReactions(ctx, teamID, discussionNumber, commentNumber, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.ListOptions.Page = resp.NextPage

		}
	}
}

// ListTeamDiscussionReactionsIter returns an iterator that paginates through all results of ListTeamDiscussionReactions.
func (s *ReactionsService) ListTeamDiscussionReactionsIter(ctx context.Context, teamID int64, discussionNumber int, opts *ListReactionOptions) iter.Seq2[*Reaction, error] {
	return func(yield func(*Reaction, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListReactionOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListTeamDiscussionReactions(ctx, teamID, discussionNumber, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.ListOptions.Page = resp.NextPage

		}
	}
}

// ListIter returns an iterator that paginates through all results of List.
func (s *RepositoriesService) ListIter(ctx context.Context, user string, opts *RepositoryListOptions) iter.Seq2[*Repository, error] {
	return func(yield func(*Repository, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &RepositoryListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.List(ctx, user, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.ListOptions.Page = resp.NextPage

		}
	}
}

// ListAutolinksIter returns an iterator that paginates through all results of ListAutolinks.
func (s *RepositoriesService) ListAutolinksIter(ctx context.Context, owner string, repo string, opts *ListOptions) iter.Seq2[*Autolink, error] {
	return func(yield func(*Autolink, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListAutolinks(ctx, owner, repo, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListBranchesIter returns an iterator that paginates through all results of ListBranches.
func (s *RepositoriesService) ListBranchesIter(ctx context.Context, owner string, repo string, opts *BranchListOptions) iter.Seq2[*Branch, error] {
	return func(yield func(*Branch, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &BranchListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListBranches(ctx, owner, repo, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.ListOptions.Page = resp.NextPage

		}
	}
}

// ListByAuthenticatedUserIter returns an iterator that paginates through all results of ListByAuthenticatedUser.
func (s *RepositoriesService) ListByAuthenticatedUserIter(ctx context.Context, opts *RepositoryListByAuthenticatedUserOptions) iter.Seq2[*Repository, error] {
	return func(yield func(*Repository, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &RepositoryListByAuthenticatedUserOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListByAuthenticatedUser(ctx, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.ListOptions.Page = resp.NextPage

		}
	}
}

// ListByOrgIter returns an iterator that paginates through all results of ListByOrg.
func (s *RepositoriesService) ListByOrgIter(ctx context.Context, org string, opts *RepositoryListByOrgOptions) iter.Seq2[*Repository, error] {
	return func(yield func(*Repository, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &RepositoryListByOrgOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListByOrg(ctx, org, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.ListOptions.Page = resp.NextPage

		}
	}
}

// ListByUserIter returns an iterator that paginates through all results of ListByUser.
func (s *RepositoriesService) ListByUserIter(ctx context.Context, user string, opts *RepositoryListByUserOptions) iter.Seq2[*Repository, error] {
	return func(yield func(*Repository, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &RepositoryListByUserOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListByUser(ctx, user, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.ListOptions.Page = resp.NextPage

		}
	}
}

// ListCollaboratorsIter returns an iterator that paginates through all results of ListCollaborators.
func (s *RepositoriesService) ListCollaboratorsIter(ctx context.Context, owner string, repo string, opts *ListCollaboratorsOptions) iter.Seq2[*User, error] {
	return func(yield func(*User, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListCollaboratorsOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListCollaborators(ctx, owner, repo, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.ListOptions.Page = resp.NextPage

		}
	}
}

// ListCommentsIter returns an iterator that paginates through all results of ListComments.
func (s *RepositoriesService) ListCommentsIter(ctx context.Context, owner string, repo string, opts *ListOptions) iter.Seq2[*RepositoryComment, error] {
	return func(yield func(*RepositoryComment, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListComments(ctx, owner, repo, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListCommitCommentsIter returns an iterator that paginates through all results of ListCommitComments.
func (s *RepositoriesService) ListCommitCommentsIter(ctx context.Context, owner string, repo string, sha string, opts *ListOptions) iter.Seq2[*RepositoryComment, error] {
	return func(yield func(*RepositoryComment, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListCommitComments(ctx, owner, repo, sha, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListCommitsIter returns an iterator that paginates through all results of ListCommits.
func (s *RepositoriesService) ListCommitsIter(ctx context.Context, owner string, repo string, opts *CommitsListOptions) iter.Seq2[*RepositoryCommit, error] {
	return func(yield func(*RepositoryCommit, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &CommitsListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListCommits(ctx, owner, repo, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.ListOptions.Page = resp.NextPage

		}
	}
}

// ListContributorsIter returns an iterator that paginates through all results of ListContributors.
func (s *RepositoriesService) ListContributorsIter(ctx context.Context, owner string, repository string, opts *ListContributorsOptions) iter.Seq2[*Contributor, error] {
	return func(yield func(*Contributor, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListContributorsOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListContributors(ctx, owner, repository, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.ListOptions.Page = resp.NextPage

		}
	}
}

// ListDeploymentStatusesIter returns an iterator that paginates through all results of ListDeploymentStatuses.
func (s *RepositoriesService) ListDeploymentStatusesIter(ctx context.Context, owner string, repo string, deployment int64, opts *ListOptions) iter.Seq2[*DeploymentStatus, error] {
	return func(yield func(*DeploymentStatus, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListDeploymentStatuses(ctx, owner, repo, deployment, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListDeploymentsIter returns an iterator that paginates through all results of ListDeployments.
func (s *RepositoriesService) ListDeploymentsIter(ctx context.Context, owner string, repo string, opts *DeploymentsListOptions) iter.Seq2[*Deployment, error] {
	return func(yield func(*Deployment, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &DeploymentsListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListDeployments(ctx, owner, repo, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.ListOptions.Page = resp.NextPage

		}
	}
}

// ListForksIter returns an iterator that paginates through all results of ListForks.
func (s *RepositoriesService) ListForksIter(ctx context.Context, owner string, repo string, opts *RepositoryListForksOptions) iter.Seq2[*Repository, error] {
	return func(yield func(*Repository, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &RepositoryListForksOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListForks(ctx, owner, repo, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.ListOptions.Page = resp.NextPage

		}
	}
}

// ListHooksIter returns an iterator that paginates through all results of ListHooks.
func (s *RepositoriesService) ListHooksIter(ctx context.Context, owner string, repo string, opts *ListOptions) iter.Seq2[*Hook, error] {
	return func(yield func(*Hook, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListHooks(ctx, owner, repo, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListInvitationsIter returns an iterator that paginates through all results of ListInvitations.
func (s *RepositoriesService) ListInvitationsIter(ctx context.Context, owner string, repo string, opts *ListOptions) iter.Seq2[*RepositoryInvitation, error] {
	return func(yield func(*RepositoryInvitation, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListInvitations(ctx, owner, repo, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListKeysIter returns an iterator that paginates through all results of ListKeys.
func (s *RepositoriesService) ListKeysIter(ctx context.Context, owner string, repo string, opts *ListOptions) iter.Seq2[*Key, error] {
	return func(yield func(*Key, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListKeys(ctx, owner, repo, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListPagesBuildsIter returns an iterator that paginates through all results of ListPagesBuilds.
func (s *RepositoriesService) ListPagesBuildsIter(ctx context.Context, owner string, repo string, opts *ListOptions) iter.Seq2[*PagesBuild, error] {
	return func(yield func(*PagesBuild, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListPagesBuilds(ctx, owner, repo, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListPreReceiveHooksIter returns an iterator that paginates through all results of ListPreReceiveHooks.
func (s *RepositoriesService) ListPreReceiveHooksIter(ctx context.Context, owner string, repo string, opts *ListOptions) iter.Seq2[*PreReceiveHook, error] {
	return func(yield func(*PreReceiveHook, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListPreReceiveHooks(ctx, owner, repo, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListReleaseAssetsIter returns an iterator that paginates through all results of ListReleaseAssets.
func (s *RepositoriesService) ListReleaseAssetsIter(ctx context.Context, owner string, repo string, id int64, opts *ListOptions) iter.Seq2[*ReleaseAsset, error] {
	return func(yield func(*ReleaseAsset, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListReleaseAssets(ctx, owner, repo, id, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListReleasesIter returns an iterator that paginates through all results of ListReleases.
func (s *RepositoriesService) ListReleasesIter(ctx context.Context, owner string, repo string, opts *ListOptions) iter.Seq2[*RepositoryRelease, error] {
	return func(yield func(*RepositoryRelease, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListReleases(ctx, owner, repo, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListStatusesIter returns an iterator that paginates through all results of ListStatuses.
func (s *RepositoriesService) ListStatusesIter(ctx context.Context, owner string, repo string, ref string, opts *ListOptions) iter.Seq2[*RepoStatus, error] {
	return func(yield func(*RepoStatus, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListStatuses(ctx, owner, repo, ref, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListTagsIter returns an iterator that paginates through all results of ListTags.
func (s *RepositoriesService) ListTagsIter(ctx context.Context, owner string, repo string, opts *ListOptions) iter.Seq2[*RepositoryTag, error] {
	return func(yield func(*RepositoryTag, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListTags(ctx, owner, repo, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListTeamsIter returns an iterator that paginates through all results of ListTeams.
func (s *RepositoriesService) ListTeamsIter(ctx context.Context, owner string, repo string, opts *ListOptions) iter.Seq2[*Team, error] {
	return func(yield func(*Team, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListTeams(ctx, owner, repo, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListAlertsForEnterpriseIter returns an iterator that paginates through all results of ListAlertsForEnterprise.
func (s *SecretScanningService) ListAlertsForEnterpriseIter(ctx context.Context, enterprise string, opts *SecretScanningAlertListOptions) iter.Seq2[*SecretScanningAlert, error] {
	return func(yield func(*SecretScanningAlert, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &SecretScanningAlertListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListAlertsForEnterprise(ctx, enterprise, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.ListOptions.Page = resp.NextPage

		}
	}
}

// ListAlertsForOrgIter returns an iterator that paginates through all results of ListAlertsForOrg.
func (s *SecretScanningService) ListAlertsForOrgIter(ctx context.Context, org string, opts *SecretScanningAlertListOptions) iter.Seq2[*SecretScanningAlert, error] {
	return func(yield func(*SecretScanningAlert, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &SecretScanningAlertListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListAlertsForOrg(ctx, org, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.ListOptions.Page = resp.NextPage

		}
	}
}

// ListAlertsForRepoIter returns an iterator that paginates through all results of ListAlertsForRepo.
func (s *SecretScanningService) ListAlertsForRepoIter(ctx context.Context, owner string, repo string, opts *SecretScanningAlertListOptions) iter.Seq2[*SecretScanningAlert, error] {
	return func(yield func(*SecretScanningAlert, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &SecretScanningAlertListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListAlertsForRepo(ctx, owner, repo, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.ListOptions.Page = resp.NextPage

		}
	}
}

// ListLocationsForAlertIter returns an iterator that paginates through all results of ListLocationsForAlert.
func (s *SecretScanningService) ListLocationsForAlertIter(ctx context.Context, owner string, repo string, number int64, opts *ListOptions) iter.Seq2[*SecretScanningAlertLocation, error] {
	return func(yield func(*SecretScanningAlertLocation, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListLocationsForAlert(ctx, owner, repo, number, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListByIssueIter returns an iterator that paginates through all results of ListByIssue.
func (s *SubIssueService) ListByIssueIter(ctx context.Context, owner string, repo string, issueNumber int64, opts *IssueListOptions) iter.Seq2[*SubIssue, error] {
	return func(yield func(*SubIssue, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &IssueListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListByIssue(ctx, owner, repo, issueNumber, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.ListOptions.Page = resp.NextPage

		}
	}
}

// ListChildTeamsByParentIDIter returns an iterator that paginates through all results of ListChildTeamsByParentID.
func (s *TeamsService) ListChildTeamsByParentIDIter(ctx context.Context, orgID int64, teamID int64, opts *ListOptions) iter.Seq2[*Team, error] {
	return func(yield func(*Team, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListChildTeamsByParentID(ctx, orgID, teamID, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListChildTeamsByParentSlugIter returns an iterator that paginates through all results of ListChildTeamsByParentSlug.
func (s *TeamsService) ListChildTeamsByParentSlugIter(ctx context.Context, org string, slug string, opts *ListOptions) iter.Seq2[*Team, error] {
	return func(yield func(*Team, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListChildTeamsByParentSlug(ctx, org, slug, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListCommentsByIDIter returns an iterator that paginates through all results of ListCommentsByID.
func (s *TeamsService) ListCommentsByIDIter(ctx context.Context, orgID int64, teamID int64, discussionNumber int, options *DiscussionCommentListOptions) iter.Seq2[*DiscussionComment, error] {
	return func(yield func(*DiscussionComment, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if options == nil {
			options = &DiscussionCommentListOptions{}
		} else {
			optsCopy := *options
			options = &optsCopy
		}

		for {
			items, resp, err := s.ListCommentsByID(ctx, orgID, teamID, discussionNumber, options)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			options.ListOptions.Page = resp.NextPage

		}
	}
}

// ListCommentsBySlugIter returns an iterator that paginates through all results of ListCommentsBySlug.
func (s *TeamsService) ListCommentsBySlugIter(ctx context.Context, org string, slug string, discussionNumber int, options *DiscussionCommentListOptions) iter.Seq2[*DiscussionComment, error] {
	return func(yield func(*DiscussionComment, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if options == nil {
			options = &DiscussionCommentListOptions{}
		} else {
			optsCopy := *options
			options = &optsCopy
		}

		for {
			items, resp, err := s.ListCommentsBySlug(ctx, org, slug, discussionNumber, options)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			options.ListOptions.Page = resp.NextPage

		}
	}
}

// ListDiscussionsByIDIter returns an iterator that paginates through all results of ListDiscussionsByID.
func (s *TeamsService) ListDiscussionsByIDIter(ctx context.Context, orgID int64, teamID int64, opts *DiscussionListOptions) iter.Seq2[*TeamDiscussion, error] {
	return func(yield func(*TeamDiscussion, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &DiscussionListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListDiscussionsByID(ctx, orgID, teamID, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.ListOptions.Page = resp.NextPage

		}
	}
}

// ListDiscussionsBySlugIter returns an iterator that paginates through all results of ListDiscussionsBySlug.
func (s *TeamsService) ListDiscussionsBySlugIter(ctx context.Context, org string, slug string, opts *DiscussionListOptions) iter.Seq2[*TeamDiscussion, error] {
	return func(yield func(*TeamDiscussion, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &DiscussionListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListDiscussionsBySlug(ctx, org, slug, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.ListOptions.Page = resp.NextPage

		}
	}
}

// ListPendingTeamInvitationsByIDIter returns an iterator that paginates through all results of ListPendingTeamInvitationsByID.
func (s *TeamsService) ListPendingTeamInvitationsByIDIter(ctx context.Context, orgID int64, teamID int64, opts *ListOptions) iter.Seq2[*Invitation, error] {
	return func(yield func(*Invitation, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListPendingTeamInvitationsByID(ctx, orgID, teamID, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListPendingTeamInvitationsBySlugIter returns an iterator that paginates through all results of ListPendingTeamInvitationsBySlug.
func (s *TeamsService) ListPendingTeamInvitationsBySlugIter(ctx context.Context, org string, slug string, opts *ListOptions) iter.Seq2[*Invitation, error] {
	return func(yield func(*Invitation, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListPendingTeamInvitationsBySlug(ctx, org, slug, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListTeamMembersByIDIter returns an iterator that paginates through all results of ListTeamMembersByID.
func (s *TeamsService) ListTeamMembersByIDIter(ctx context.Context, orgID int64, teamID int64, opts *TeamListTeamMembersOptions) iter.Seq2[*User, error] {
	return func(yield func(*User, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &TeamListTeamMembersOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListTeamMembersByID(ctx, orgID, teamID, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.ListOptions.Page = resp.NextPage

		}
	}
}

// ListTeamMembersBySlugIter returns an iterator that paginates through all results of ListTeamMembersBySlug.
func (s *TeamsService) ListTeamMembersBySlugIter(ctx context.Context, org string, slug string, opts *TeamListTeamMembersOptions) iter.Seq2[*User, error] {
	return func(yield func(*User, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &TeamListTeamMembersOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListTeamMembersBySlug(ctx, org, slug, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.ListOptions.Page = resp.NextPage

		}
	}
}

// ListTeamReposByIDIter returns an iterator that paginates through all results of ListTeamReposByID.
func (s *TeamsService) ListTeamReposByIDIter(ctx context.Context, orgID int64, teamID int64, opts *ListOptions) iter.Seq2[*Repository, error] {
	return func(yield func(*Repository, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListTeamReposByID(ctx, orgID, teamID, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListTeamReposBySlugIter returns an iterator that paginates through all results of ListTeamReposBySlug.
func (s *TeamsService) ListTeamReposBySlugIter(ctx context.Context, org string, slug string, opts *ListOptions) iter.Seq2[*Repository, error] {
	return func(yield func(*Repository, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListTeamReposBySlug(ctx, org, slug, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListTeamsIter returns an iterator that paginates through all results of ListTeams.
func (s *TeamsService) ListTeamsIter(ctx context.Context, org string, opts *ListOptions) iter.Seq2[*Team, error] {
	return func(yield func(*Team, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListTeams(ctx, org, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListUserTeamsIter returns an iterator that paginates through all results of ListUserTeams.
func (s *TeamsService) ListUserTeamsIter(ctx context.Context, opts *ListOptions) iter.Seq2[*Team, error] {
	return func(yield func(*Team, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListUserTeams(ctx, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListAllIter returns an iterator that paginates through all results of ListAll.
func (s *UsersService) ListAllIter(ctx context.Context, opts *UserListOptions) iter.Seq2[*User, error] {
	return func(yield func(*User, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &UserListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListAll(ctx, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.ListOptions.Page = resp.NextPage

		}
	}
}

// ListBlockedUsersIter returns an iterator that paginates through all results of ListBlockedUsers.
func (s *UsersService) ListBlockedUsersIter(ctx context.Context, opts *ListOptions) iter.Seq2[*User, error] {
	return func(yield func(*User, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListBlockedUsers(ctx, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListEmailsIter returns an iterator that paginates through all results of ListEmails.
func (s *UsersService) ListEmailsIter(ctx context.Context, opts *ListOptions) iter.Seq2[*UserEmail, error] {
	return func(yield func(*UserEmail, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListEmails(ctx, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListFollowersIter returns an iterator that paginates through all results of ListFollowers.
func (s *UsersService) ListFollowersIter(ctx context.Context, user string, opts *ListOptions) iter.Seq2[*User, error] {
	return func(yield func(*User, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListFollowers(ctx, user, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListFollowingIter returns an iterator that paginates through all results of ListFollowing.
func (s *UsersService) ListFollowingIter(ctx context.Context, user string, opts *ListOptions) iter.Seq2[*User, error] {
	return func(yield func(*User, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListFollowing(ctx, user, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListGPGKeysIter returns an iterator that paginates through all results of ListGPGKeys.
func (s *UsersService) ListGPGKeysIter(ctx context.Context, user string, opts *ListOptions) iter.Seq2[*GPGKey, error] {
	return func(yield func(*GPGKey, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListGPGKeys(ctx, user, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListInvitationsIter returns an iterator that paginates through all results of ListInvitations.
func (s *UsersService) ListInvitationsIter(ctx context.Context, opts *ListOptions) iter.Seq2[*RepositoryInvitation, error] {
	return func(yield func(*RepositoryInvitation, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListInvitations(ctx, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListKeysIter returns an iterator that paginates through all results of ListKeys.
func (s *UsersService) ListKeysIter(ctx context.Context, user string, opts *ListOptions) iter.Seq2[*Key, error] {
	return func(yield func(*Key, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListKeys(ctx, user, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListPackagesIter returns an iterator that paginates through all results of ListPackages.
func (s *UsersService) ListPackagesIter(ctx context.Context, user string, opts *PackageListOptions) iter.Seq2[*Package, error] {
	return func(yield func(*Package, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &PackageListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListPackages(ctx, user, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.ListOptions.Page = resp.NextPage

		}
	}
}

// ListSSHSigningKeysIter returns an iterator that paginates through all results of ListSSHSigningKeys.
func (s *UsersService) ListSSHSigningKeysIter(ctx context.Context, user string, opts *ListOptions) iter.Seq2[*SSHSigningKey, error] {
	return func(yield func(*SSHSigningKey, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListSSHSigningKeys(ctx, user, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListSocialAccountsIter returns an iterator that paginates through all results of ListSocialAccounts.
func (s *UsersService) ListSocialAccountsIter(ctx context.Context, opts *ListOptions) iter.Seq2[*SocialAccount, error] {
	return func(yield func(*SocialAccount, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListSocialAccounts(ctx, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}

// ListUserSocialAccountsIter returns an iterator that paginates through all results of ListUserSocialAccounts.
func (s *UsersService) ListUserSocialAccountsIter(ctx context.Context, username string, opts *ListOptions) iter.Seq2[*SocialAccount, error] {
	return func(yield func(*SocialAccount, error) bool) {

		// Create a copy of opts to avoid mutating the caller's struct
		if opts == nil {
			opts = &ListOptions{}
		} else {
			optsCopy := *opts
			opts = &optsCopy
		}

		for {
			items, resp, err := s.ListUserSocialAccounts(ctx, username, opts)
			if err != nil {
				yield(nil, err)
				return
			}

			for _, item := range items {
				if !yield(item, nil) {
					return
				}
			}

			if resp.NextPage == 0 {
				break
			}

			opts.Page = resp.NextPage

		}
	}
}
